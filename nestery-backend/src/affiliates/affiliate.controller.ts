import {
  Controller,
  Post,
  Body,
  Get,
  Param,
  Query,
  UseGuards,
  Req,
  Res,
  HttpStatus,
  NotFoundException,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { Response as ExpressResponse } from 'express';
import { PartnerService } from './services/partner.service';
import { AffiliateOfferService } from './services/affiliate-offer.service';
import { TrackableLinkService } from './services/trackable-link.service';
import { CreatePartnerDto } from './dto/create-partner.dto';
import { CreateOfferDto } from './dto/create-offer.dto';
import { PartnerResponseDto } from './dto/partner.response.dto';
import { OfferResponseDto } from './dto/offer.response.dto';
import { GeneratedAffiliateLinkResponseDto } from './dto/link.response.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Public } from '../auth/decorators/public.decorator';
import { AuthenticatedRequest } from '../auth/interfaces/authenticated-request.interface';

@ApiTags('affiliates')
@Controller('affiliates')
export class AffiliateController {
  constructor(
    private readonly partnerService: PartnerService,
    private readonly affiliateOfferService: AffiliateOfferService,
    private readonly trackableLinkService: TrackableLinkService,
  ) {}

  @Post('partners/register')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin') // Or a specific partner management role
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Register a new affiliate partner' })
  @ApiResponse({ status: 201, description: 'Partner registered successfully', type: PartnerResponseDto })
  @ApiResponse({ status: 400, description: 'Bad Request' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  async registerPartner(@Body() createPartnerDto: CreatePartnerDto): Promise<PartnerResponseDto> {
    const partner = await this.partnerService.registerPartner(createPartnerDto);
    return PartnerResponseDto.fromEntity(partner);
  }

  @Post('partners/:partnerId/offers')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin') // Or a specific partner management role
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Create a new affiliate offer for a partner' })
  @ApiParam({ name: 'partnerId', description: 'ID of the partner' })
  @ApiResponse({ status: 201, description: 'Offer created successfully', type: OfferResponseDto })
  @ApiResponse({ status: 400, description: 'Bad Request' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  @ApiResponse({ status: 403, description: 'Forbidden' })
  @ApiResponse({ status: 404, description: 'Partner not found' })
  async createOffer(
    @Param('partnerId') partnerId: string,
    @Body() createOfferDto: CreateOfferDto,
  ): Promise<OfferResponseDto> {
    const offer = await this.affiliateOfferService.createOffer(partnerId, createOfferDto);
    return OfferResponseDto.fromEntity(offer);
  }

  @Get('offers/:offerId/trackable-link')
  @UseGuards(JwtAuthGuard) // Or Public() if links can be generated by anyone
  @ApiBearerAuth() // Remove if Public()
  @ApiOperation({ summary: 'Generate a trackable affiliate link for an offer' })
  @ApiParam({ name: 'offerId', description: 'ID of the affiliate offer' })
  @ApiQuery({ name: 'userId', description: 'Optional ID of the user generating the link', required: false })
  @ApiResponse({ status: 200, description: 'Trackable link generated', type: GeneratedAffiliateLinkResponseDto })
  @ApiResponse({ status: 404, description: 'Offer not found or inactive' })
  async generateTrackableLink(
    @Param('offerId') offerId: string,
    @Query('userId') userId?: string,
    @Req() req?: AuthenticatedRequest, // If not public, use req.user.id if userId query param is not provided
  ): Promise<GeneratedAffiliateLinkResponseDto> {
    const actualUserId = userId || (req?.user?.id);
    const result = await this.trackableLinkService.generateAffiliateLink(offerId, actualUserId);
    return {
      linkEntity: result.linkEntity,
      fullTrackableUrl: result.fullTrackableUrl,
      qrCodeDataUrl: result.qrCodeDataUrl,
    };
  }

  @Public()
  @Get('redirect/:uniqueCode')
  @ApiOperation({ summary: 'Redirects user via trackable link and tracks click' })
  @ApiParam({ name: 'uniqueCode', description: 'Unique code of the affiliate link' })
  @ApiResponse({ status: 302, description: 'Redirects to original URL' })
  @ApiResponse({ status: 404, description: 'Link not found or invalid' })
  async handleRedirect(
    @Param('uniqueCode') uniqueCode: string,
    @Res() res: ExpressResponse,
  ): Promise<void> {
    const originalUrl = await this.trackableLinkService.handleLinkRedirectAndTrackClick(
      uniqueCode,
    );
    if (originalUrl) {
      res.redirect(HttpStatus.FOUND, originalUrl);
    } else {
      // Optionally redirect to a fallback page or return a 404
      // For now, sending a 404 response directly
      throw new NotFoundException('Affiliate link is invalid or has expired.');
    }
  }

  // Example of getting an offer (can be expanded)
  @Get('offers/:offerId')
  @Public() // Or protected
  @ApiOperation({ summary: 'Get details of an affiliate offer' })
  async getOffer(@Param('offerId') offerId: string): Promise<OfferResponseDto> {
    const offer = await this.affiliateOfferService.getOfferById(offerId);
    if (!offer) throw new NotFoundException('Offer not found');
    return OfferResponseDto.fromEntity(offer);
  }
}
